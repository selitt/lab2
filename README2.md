## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2402`

#### Выполнил: `Забирохин Всеволод Сергеевич`

#### Вариант: `9`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Математическая модель](#25-математическая-модель)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи
- Условие

> Напишите программу на Java, которая выполняет следующие действия
с одномерным массивом строк:
>1. Считывает с консоли число N, затем N строк и заполняет массив
размером N.
>2. Упорядочивает строки по количеству слов в них. Если количество
слов одинаковое, сортирует в порядке возрастания числа гласных
букв. Если и это одинаково, сортирует строки по длине.
>3. Находит и выводит самую часто встречающуюся букву во всех
строках (без учёта регистра). Если таких букв несколько, выводит
все.
>4. Выводит все палиндромы среди введённых строк, а также количество таких строк.
>5. Соединяет все строки в одну, разделяя их запятыми, если строка не
заканчивается знаком препинания. Затем подсчитывает количество
слов в полученной строке и выводит результат.


- Подробное описание, как Вы понимаете, того, что вам нужно сделать. Можно с примерами
>1. Программа считывает целое число n, после чего создает и заполняет массив n строками, введенными с клавиатуры
>2. Программа проверяет сколько слов находится в каждой строке, если количество слов разное - переставляет их местами, если нет -
сравнивает строки по количеству гласных в них букв, если и по этому признаку не получилось отсортировать, сравнивает строки по длине
### 2. Входные и выходные данные

- На вход программе подается целое число n, за ним подается n строк
- Программа должна вывести n отсортированных строк, символ - буква, которая является самой встречающейся, если в массиве есть строки-палиндромы, то выводятся они, а также строку соединенную из всех строк массива


### 3. Выбор структуры данных

На вход программе подается целое число n типа `int`, за ним подается n строк типа `String`, которые хранятся в массиве длины n

### 4. Алгоритм и матмодель

>1. Программа получает число n (длину массива), создает массив строк данной длины и заполняет с помощью цикла его, запрашивая данные у пользователя
>2. в условии задачи указана сортировка по следующим приоритетам:
> 1) по количеству слов
> 2) по количеству гласных
> 3) по длине строки
>по количеству слов : разбиваем строку по пробелам и проверяем не является ли подстрока пустой или спец > символом, если нет - добавляем в сумму
> по количеству гласных: создаем список из гласных кириллицы и латиницы, пробегаемся по строкам и проверяем каждый символ, сравнивая со списком гласных букв, используя вложенные циклы
> по длине строки: сравниваем длины строк через функцию `lenght`
>3. Программа находит одну или несколько самых частовстречающихся букв и выводит их на экран
> создаем массив букв, добавляем в него все буквы кириллицы и все буквы латиницы, создаем второй массив с такой же длиной, как и у массива букв. Пробегаемся по каждому символу в строке и ищем его в списке букв, как только нашли, прибавляем 1 ко второму массиву(тому же индексу, которому принадлежит буква в первом массиве). после того, как мы пробежались по всем строкам, необходимо пройтись еще раз по нашему данному массиву еще раз и если наш элемент равен максимальному, выводим его.
>4. вывести все палиндромы
> Мы пробегаемся по нашей строке слева и справа одновременно и сравниваем соответствующие элементы, если они равны до середины, значит, это палиндром
>5. Сложение строк и вывод количества слов.
> Сложение строк: пробегаемся по массиву с знаками препинания и сравниваем с каждым из них последний символ строки, если они равны, прибавляем строку без добавления запятой, если нет - добавляем запятую в конце. Если строка заканчивается запятой, ее мы убираем.
> вывод количества слов: сравниваем каждый текущий символ со специальным символом, если он  не равны и символ не находится внутри слова, значит это новое слово
>4. программа


### 5. Программа

Полный текст программы с комментариями на русском языке

Нужно вставить код прямо в отчет в блок:

```markdown
    ```java
         Java
import java.io.PrintStream;
import java.util.Scanner;

public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) {
        // 1 задание
        // Ввод количества строк
        System.out.print("Введите количество строк: ");
        int n = in.nextInt();
        in.nextLine(); //очищение буфера

        String[] a = new String[n]; // Создание массива строк

        // Заполнение массива элементами
        for (int i = 0; i < n; i++) {
            a[i] = in.nextLine();
        }
        // 2 задание
        // создание массивов специальных символов
        char [] Symbols2 = {'`', '~', '!', '@', '№', '#', '$', '%', '^', '&', '*', '(', ')', '-', '_', '+', '=', '{', '[', '}', ']', '|', ':', ';', '<', ',', '.', '>', '?', '/', ' '};
        String [] Symbols = {"`", "~", "!", "@", "№", "#", "$", "%", "^", "&", "*", "(", ")", "-", "_", "+", "=", "{", "[", "}", "]", "|", ":", ";", "'", "<", ",", ".", ">", "?", "/"};
        // 2 задание
        for (int j = 1; j < n; j++) {
            for (int i = 0; i < n - j; i++) {
                String[] arr1 = a[i].split(" "); // разбиение массива на слова по пробелам
                int counter1 = 0; // счётчик слов
                int count1 = 0; // счётчик правильности выполнения условия на спец символы
                for (int k = 0; k < arr1.length; k++) {
                    if (!arr1[k].isEmpty()) {
                        for (int l = 0; l < Symbols2.length; l++) {
                            if (arr1[k].charAt(arr1[k].length() - 1) != Symbols2[l]) // проверка на то, не является ли слово спецсимволом
                                count1++;
                            if (count1 == Symbols2.length) // если слово не спецсимвол - прибавляем к счётчику 1
                                counter1++;
                        }
                    }
                }
                String[] arr2 = a[i + 1].split(" ");
                int counter2 = 0; // счётчик слов
                int count2 = 0; // счётчик правильности выполнения условия на спец символы
                for (int k = 0; k < arr2.length; k++) {
                    if (!arr2[k].isEmpty()) {
                        for (int m = 0; m < Symbols2.length; m++) {
                            if (arr2[k].charAt(arr2[k].length() - 1) != Symbols2[m]) // проверка на то, не является ли слово спецсимволом
                                count2 += 1;
                            if (count2 == Symbols2.length) // если слово не спецсимвол - прибавляем к счётчику 1
                                counter2 += 1;
                        }
                    }
                }
                // если число слов разное - сортируем список
                if (counter1 > counter2) {
                    String z = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = z;
                } else if (counter1 == counter2) {
                    char[] bukva = {'у', 'е', 'ы', 'а', 'о', 'я', 'и', 'э', 'ю', 'ё', 'e', 'u', 'i', 'o', 'a', 'y'}; // список гласных букв
                    int bcounter1 = 0; // счётчики гласных букв
                    int bcounter2 = 0;
                    for (int k = 0; k < a[i].length(); k++) {
                        for (int h = 0; h < bukva.length; h++) {
                            if (bukva[h] == a[i].charAt(k)) { // проверяем на гласность буквы слова
                                bcounter1 += 1;
                            }
                        }
                    }
                    for (int k = 0; k < a[i + 1].length(); k++) {
                        for (int h = 0; h < bukva.length; h++) {
                            if (bukva[h] == a[i + 1].charAt(k)) { // проверка на гласность букв слова
                                bcounter2 += 1;
                            }
                        }
                    }
                    // если число гласных букв разное - сортируем
                    if (bcounter1 > bcounter2) {
                        String z = a[i];

                        a[i] = a[i + 1];
                        a[i + 1] = z;
                        // если мы не отсортировали по предыдущим двум признакам - сортируем по длине
                    } else if (bcounter1 == counter2) {
                        if (a[i].length() > a[i + 1].length()) {
                            String z = a[i];
                            a[i] = a[i + 1];
                            a[i + 1] = z;
                        }
                    }
                }
            }
        }
        // вывод отсортированного массива
        for (int i = 0; i < a.length; i++){
            out.println(a[i]);
        }
        out.println("Частые буквы:");
        // 3 задание
        char[] alphabet = new char[59]; // создание массива алфавита латиницы и кириллицы
        for (int i = 0; i < 26; i++) {
            alphabet[i] = (char) ('a' + i); // заполнение массива латиницей
        }
        for (int i = 0; i < 32; i++) {
            alphabet[26 + i] = (char) ('а' + i); // заполнение массива кириллицей
        }
        alphabet[58] = 'ё'; // добавление буквы ё
        int [] alphabet_count = new int[59]; // создаем пустой массив с индексами букв
        for(int i = 0; i < a.length; i++){
            String s = a[i];
            for(int j = 0; j < s.length(); j++){
                char bukva = s.charAt(j);
                for(int k = 0; k < alphabet.length; k++){ // если символ является буквой из списка на его номер в массиве alphebet_count увеличивается число
                    if(alphabet[k] == bukva){
                        alphabet_count[k] += 1;
                    }
                }
            }
        }
        int max = alphabet_count[0];
        for(int i = 1; i < alphabet_count.length; i++){ // находим номер максимальной буквы
            if(alphabet_count[i] > max){
                max = alphabet_count[i];
            }
        }
        for(int i = 0; i<alphabet_count.length; i++){ // вывод максимальной буквы
            if(alphabet_count[i] == max){
                out.print(alphabet[i] + " ");
            }
        }
        out.println();
        // 4 задание
        int count_p = 0;
        out.println("Палиндромы:"); // Заголовок для вывода палиндромов
        for (int i = 0; i < n; i++) {
            String line = a[i];
            int left = 0;
            int right = line.length() - 1;
            boolean isPalindrome = true; // Флаг для определения палиндрома
            while (left <= right) {
                if (line.charAt(left) != line.charAt(right)) {
                    isPalindrome = false; // Если символы не равны, это не палиндром
                    break; // Выходим из цикла при первом несовпадении
                }
                left++;
                right--;
            }
            if (isPalindrome) { // Если строка палиндром
                out.println(line);// Выводим палиндром
                count_p++;
            if (count_p == 0)
                out.println("нет");
            }
        }
        // задание 5

        String NewLine = "";
        boolean WithSymbol = false;

// Проверяем, заканчивается ли строка на специальный символ
        for (int i = 0; i < a.length; i++) {
            String line  = a[i];
            WithSymbol = false; // Сбрасываем флаг для каждой новой строки
            for (int j = 0; j < Symbols.length; j++) {
                if (line.length() > 0 && line.charAt(line.length() - 1) == Symbols[j].charAt(0)) {
                    WithSymbol = true; // Устанавливаем флаг, если нашли совпадение
                    break;
                }
            }

            // Если строка заканчивается на специальный символ, добавляем её без запятой
            if (WithSymbol) {
                NewLine += line;
            } else {
                // Если не окончена специальным символом, добавляем запятую
                NewLine += line + ",";
            }
        }

// Для подсчета количества слов, игнорируя специальные символы
        int CountWords = 0;
        boolean inWord = false; // Флаг для отслеживания нахождения внутри "слова"


        for (int i = 0; i < NewLine.length(); i++) {
            char currentChar = NewLine.charAt(i);
            boolean isSymbol = false;

            // Проверяем, является ли текущий символ специальным
            for (int h = 0; h < Symbols2.length; h++) {
                if (currentChar == Symbols2[h]) {
                    isSymbol = true; // Найден специальный символ
                    break;
                }
            }

            // Если символ не специальный, проверяем, находимся ли мы внутри слова
            if (!isSymbol) {
                if (!inWord) {
                    CountWords++; // Если мы не были внутри слова, значит, находим новое слово
                    inWord = true; // Устанавливаем флаг, что находимся внутри слова
                }
            } else {
                // Если текущий символ — специальный, сбрасываем флаг
                inWord = false;
            }
        }

// Удаление последней запятой, если она есть
        if (NewLine.endsWith(",")) {
            NewLine = NewLine.substring(0, NewLine.length() - 1);
        }

        out.println(NewLine);
        out.println(CountWords);

    }
}

    ``` 
```


### 6. Анализ правильности решения

Привести тесты и анализ работы программы для этих тестов.
Очень неплохо было бы обосновать выбор тестов.

1. Цель теста: Проверить, что программа сортирует строки правильно: сначала по количеству слов, потом по количеству гласных, и если всё одинаково — по длине строки.

   - Input:
       ```
       4
     hello world
     java is great
     a small example of a string
     simple
       ```

     - Output:
     ```
      simple
      hello world
      java is great
      a small example of a string
      Частые буквы:
      a l
      Палиндромы:
      нет
      соединенная строка: simple,hello world,java is great,a small example of a string
      количество слов в строке: 12
     ```

2. Цель теста: Проверить, что программа правильно находит наиболее часто встречающиеся буквы, игнорируя регистр.

- Input:
    ```
    3
    hello world
    java is great
    open ai
    ```

- Output:
    ```
    hello world
    open ai
    java is great
    Частые буквы:
    a 
    Палиндромы:
    нет
    соединенная строка:     hello world,    open ai,    java is great
    количество слов в строке: 7
    ```
3. Цель теста: Проверить, что программа правильно находит палиндромы среди строк и правильно выводит их количество.
- Input:
    ```
    5
    madam
    hello
    racecar
    java
    level
    ```
- Output:
    ```
    madam
    hello
    java
    level
    racecar
    Частые буквы:
    a 
    Палиндромы:
    madam
    level
    racecar
    соединенная строка: madam,hello,java,level,racecar
    количество слов в строке: 5
    ```
4. Цель теста: Убедиться, что программа корректно обрабатывает пустые строки
- Input:
    ```
    3
    hello
         
    world
    ```
- Output:
    ```
         
    world
    hello
    Частые буквы:
    l 
    Палиндромы:
         
    соединенная строка:          ,    world,    hello
    количество слов в строке: 2
    ```
5. Цель теста: Убедиться, что программа правильно работает с несколькими буквами, которые встречаются одинаково часто.
- Input:
    ```
    3
    aaa
    bbb
    ccc
    ```
- Output:
    ```
    bbb
    ccc
    aaa
    Частые буквы:
    a b c 
    Палиндромы:
    нет
    соединенная строка:     bbb,    ccc,    aaa
    количество слов в строке: 3
    ```